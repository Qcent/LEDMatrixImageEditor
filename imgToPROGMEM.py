import numpy as np
from PIL import Image
import sys
import pyperclip
import os


def strip_extension(file_name):
    base_name = os.path.splitext(file_name)[0]
    return base_name


def copy_to_clipboard(text):
    pyperclip.copy(text)


def scale_8bit_to_nbit(value, num_bits):
    if not (0 <= value <= 255):
        raise ValueError("Input value must be an 8-bit integer (0-255)")
    if not (1 <= num_bits <= 32):
        raise ValueError("numBits must be between 1 and 32")

    max_8bit = 255  # Maximum value for 8-bit
    max_nbit = (1 << num_bits) - 1  # Maximum value for numBits

    # Scale the value
    scaled_value = round((value / max_8bit) * max_nbit)

    return scaled_value


def rgb_to_rgb565(r, g, b):
    r_5bit = scale_8bit_to_nbit(r, 5)
    g_6bit = scale_8bit_to_nbit(g, 6)
    b_5bit = scale_8bit_to_nbit(b, 5)
    rgb565 = (r_5bit << 11) | (g_6bit << 5) | b_5bit
    return rgb565


def png_to_bitmap_array(img):
    # Convert image to numpy array
    img_array = np.array(img)

    # Convert RGBA values to 565 format, setting transparent pixels to 0x0000
    bitmap_array = []
    for row in img_array:
        for r, g, b, a in row:
            if a < 20:  # Check if the pixel is transparent
                rgb565 = 0x0000
            else:
                rgb565 = rgb_to_rgb565(r, g, b)
            bitmap_array.append(f'0x{rgb565:04X}')
    return bitmap_array


def format_bitmap_array(bitmap_array, file_name, w, h):
    if not (0 <= w <= 255):
        raise ValueError("Width must be an 8-bit integer (0-255)")
    if not (0 <= h <= 255):
        raise ValueError("Height must be an 8-bit integer (0-255)")
    img_name = strip_extension(file_name)

    output = f"""// Generated by   : QcentPNGConverter v0.1
// Generated from : {file_name}
// Image Size     : {w}x{h} pixels


#if defined(__AVR__)
#include <avr/pgmspace.h>
#elif defined(__PIC32MX__)
#define PROGMEM
#elif defined(__arm__)
#define PROGMEM
#endif

const unsigned short
    {img_name}_DATA[{(w * h) + 1}] PROGMEM =
        {{
            ({w} << 8) | {h}, // First two bytes: width and height
"""
    line_length = w
    pixel_count = 0

    for i in range(0, len(bitmap_array), line_length):
        line = bitmap_array[i:i + line_length]
        output += '            ' + ', '.join(line) + ', // 0x{:04X} ({} pixels)\n'.format(pixel_count,
                                                                                          pixel_count + len(line))
        pixel_count += len(line)

    output += "};\n"
    output += f"const unsigned short *{img_name} = {img_name}_DATA + 1;"

    return output


def main():
    if len(sys.argv) != 2:
        print("Usage: python script.py <path_to_image.png>")
        return

    file_path = sys.argv[1]
    file_name = file_path.split('/')[-1]  # Extract the file name from the path

    # Open the image and convert it to RGBA
    img = Image.open(file_path).convert('RGBA')

    bitmap_array = png_to_bitmap_array(img)
    formatted_output = format_bitmap_array(bitmap_array, file_name, img.width, img.height)
    print(formatted_output)
    copy_to_clipboard(formatted_output)


if __name__ == "__main__":
    main()
